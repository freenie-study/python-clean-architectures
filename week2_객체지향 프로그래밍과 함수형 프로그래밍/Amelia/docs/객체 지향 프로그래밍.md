# 객체 지향 프로그래밍

### 캡슐화(Encapsulation)
- 객체의 필드와 메서드를 하나로 묶고, 실제 구현 내용을 감추는 것
- OO언어는 데이터와 함수가 응집력 있게 구성된 집단을 구분 짓는 선을 그을 수 있고, 구분선 바깥에서 데이터는 은닉되고, 일부 함수만이 외부에 노출된다

### 상속(Inheritance)
- 상위 클래스의 속성과 기능을 하위 클래스가 물려받는 것
- 어떤 변수와 함수를 하나의 유효 범위로 묶어서 재정의하는 것

### 다형성(Polymorphism)
- e.g. 플러그인 : 입출력 장치 독립성을 지원
- c++ 가상 함수(Virtual Function) :  파생 클래스에서 재정의할 것으로 기대하는 멤버 함수, 자신을 호출하는 객체의 동적 타입에 따라 실제 호출할 함수가 결정
- 같은 이름의 메서드가 서로 다른 방식으로 동작하는 것
- 하나의 이름으로 여러가지 기능을 수행할 수 있도록 하는 것
- 오버로딩(Overloading) : 같은 이름의 메서드를 매개변수의 타입이나 개수에 따라 다르게 정의하는 것
- 오버라이딩(Overriding) : 상위 클래스의 메서드를 하위 클래스에서 재정의하는 것
- 동적 바인딩(Dynamic Binding) : 실행 시간에 어떤 메서드를 호출할지 결정하는 것
- 정적 바인딩(Static Binding) : 컴파일 시간에 어떤 메서드를 호출할지 결정하는 것
- 추상 클래스(Abstract Class) : 하위 클래스에서 반드시 재정의해야 하는 함수를 포함하는 클래스
- 인터페이스(Interface) : 추상 클래스와 비슷하지만, 추상 클래스는 하나의 클래스만 상속받을 수 있지만, 인터페이스는 여러 개를 상속받을 수 있다

### 의존성 역전
- 전현적인 호출 트리: main함수 -> 고수준 함수 ->  중간 수준 함수 -> 저수준 함수
- 전형적인 호출 트리는 소스 코드 의존성의 방향은 반드시 제어흐름을 따른다
- 다형성 사용(e.g. 인터페이스 추가) -> 제어 흐름과 소스 코드 의존성의 방향이 반대가 될 수 있다
- 배포 독립성(Independent Deployability) : 소스 코드 의존성의 방향이 제어 흐름과 반대가 되어도, 소스 코드를 재컴파일하지 않고도 배포할 수 있다
- 개발 독립성(Independent Developability) : 서로 다른 팀에서 각 모듈을 독립적 개발 가능

### 결론
- OO란 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력